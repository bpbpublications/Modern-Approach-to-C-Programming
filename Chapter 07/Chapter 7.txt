Declaring and using structures:// Define a structurestruct Student {    char name[50];    int age;    float grade;};int main() {    // Declare a structure variable    struct Student s1;    // Assign values to members    strcpy(s1.name, "Alice");    s1.age = 20;    s1.grade = 8.5;    // Access and print members    printf("Name: %s\n", s1.name);    printf("Age: %d\n", s1.age);    printf("Grade: %.2f\n", s1.grade);    return 0;}Declaring and using unions:// Define a unionunion Data {    int i;    float f;    char str[20];};int main() {    // Declare a union variable    union Data data;    // Assign and print integer value    data.i = 10;    printf("Integer: %d\n", data.i);    // Assign and print float value    data.f = 220.5;    printf("Float: %.2f\n", data.f);    // Assign and print string value    strcpy(data.str, "Hello");    printf("String: %s\n", data.str);    return 0;}Declaration: struct Student {    char name[50];    int age;    float grade;};Creating variables: After declaring a structure, you can create variables of that type.struct Student s1;  // Declares a variable of type StudentAccessing members: Members of a structure can be accessed using the dot operator (.).strcpy(s1.name, "Alice");  // Assigning a value to the name members1.age = 20;               // Assigning a value to the age memberArrays of structures: You can also create an array of structures to manage multiple records easily.struct Student students[3];  // Array of 3 Student structuresPassing Structures to Functions: Structures can be passed to functions by value or by reference (using pointers).void printStudent(struct Student s) { /* ... */ }Processing unionsDeclaration: Unions are declared similarly to structures using the union keyword.union Data {    int i;    float f;    char str[20];};Creating variables: union Data data;  // Declares a variable of type DataAccessing members: data.i = 10;  // Assigning value to the integer memberSize considerations: The size of a union is determined by the size of its largest member. You can check the size of a union using the sizeof operator.printf("Size of union: %zu\n", sizeof(data));  // Displays the size of the unionUsing unions in functions: Like structures, unions can be passed to functions. Care should be taken to ensure that only the intended member is accessed within the function.void processData(union Data d) { /* ... */ }Passing structures by value: Example of passing by value:#include <stdio.h>#include <string.h>// Define a structurestruct Student {    char name[50];    int age;    float grade;};// Function to print student detailsvoid printStudent(struct Student s) {    printf("Name: %s\n", s.name);    printf("Age: %d\n", s.age);    printf("Grade: %.2f\n", s.grade);}int main() {    struct Student student1;    strcpy(student1.name, "Alice");    student1.age = 20;    student1.grade = 8.5;    // Pass the structure to the function    printStudent(student1); // student1 remains unchanged    return 0;}Passing structures by reference:Example of passing by reference:#include <stdio.h>#include <string.h>// Define a structurestruct Student {    char name[50];    int age;    float grade;};// Function to modify student detailsvoid updateStudent(struct Student *s) {    strcpy(s->name, "Bob"); // Update the name    s->age = 21;            // Update the age    s->grade = 9.0;        // Update the grade}int main() {    struct Student student1;    strcpy(student1.name, "Alice");    student1.age = 20;    student1.grade = 8.5;    // Pass the address of the structure to the function    updateStudent(&student1); // student1 is modified    // Print updated student details    printf("Updated Student:\n");    printf("Name: %s\n", student1.name);    printf("Age: %d\n", student1.age);    printf("Grade: %.2f\n", student1.grade);    return 0;}Example of pointer declaration:#include <stdio.h>int main() {    int var = 20;    // Declare an integer variable    int *ptr;       // Declare a pointer to an integer    ptr = &var;     // Assign the address of var to ptr    printf("Value of var: %d\n", var);          // Prints the value of var    printf("Address of var: %p\n", (void*)&var); // Prints the address of var    printf("Value of ptr: %p\n", (void*)ptr);   // Prints the value of ptr (address of var)    printf("Value pointed by ptr: %d\n", *ptr);  // Dereference ptr to get the value of var    return 0;}Example of pointer arithmetic:#include <stdio.h>int main() {    int arr[] = {10, 20, 30, 40, 50}; // Declare an array    int *ptr = arr; // Point to the first element of the array    printf("Using pointer arithmetic:\n");    for (int i = 0; i < 5; i++) {        printf("Element %d: %d\n", i, *(ptr + i)); // Accessing array elements using pointer    }    return 0;}Dynamic memory allocation:#include <stdio.h>#include <stdlib.h>int main() {    int *arr;    int n;    printf("Enter number of elements: ");    scanf("%d", &n);    // Allocate memory for n integers    arr = (int*)malloc(n * sizeof(int));    // Check if memory allocation was successful    if (arr == NULL) {        printf("Memory allocation failed\n");        return 1;    }    // Initialize and display the array    for (int i = 0; i < n; i++) {        arr[i] = i + 1;        printf("%d ", arr[i]);    }    printf("\n");    // Free the allocated memory    free(arr);    return 0;}Example of pointer to pointer:#include <stdio.h>int main() {    int var = 30;    int *ptr = &var;    // Pointer to an integer    int **pptr = &ptr;  // Pointer to a pointer    printf("Value of var: %d\n", var);        // Prints 30    printf("Value pointed by ptr: %d\n", *ptr); // Prints 30    printf("Value pointed by pptr: %d\n", **pptr); // Prints 30    return 0;}Example of function pointer:#include <stdio.h>// Define a functionvoid displayMessage() {    printf("Hello, World!\n");}int main() {    // Declare a function pointer    void (*funcPtr)() = displayMessage;    // Call the function using the pointer    funcPtr();    return 0;}data_type *pointer_name;Example:#include <stdio.h>int main() {    int *ptr;  // Declaring a pointer to an integer    double *dPtr; // Declaring a pointer to a double    return 0;}Example:#include <stdio.h>int main() {    int var = 10;    // Declare an integer variable    int *ptr = &var; // Initialize ptr with the address of var    printf("Value of var: %d\n", var);           // Prints 10    printf("Address of var: %p\n", (void*)&var); // Prints the address of var    printf("Value of ptr: %p\n", (void*)ptr);    // Prints the address stored in ptr    printf("Value pointed by ptr: %d\n", *ptr);   // Dereference ptr to get the value of var    return 0;}Example:#include <stdio.h>int main() {    int var = 20;    int *ptr = &var;    printf("Original value of var: %d\n", *ptr); // Prints 20    // Modify the value of var using the pointer    *ptr = 30;    printf("Modified value of var: %d\n", var); // Prints 30    return 0;}Example of pointer arithmetic:#include <stdio.h>int main() {    int arr[] = {10, 20, 30, 40, 50}; // Declare an array    int *ptr = arr; // Initialize ptr to point to the first element of the array    // Accessing array elements using pointer arithmetic    for (int i = 0; i < 5; i++) {        printf("Element %d: %d\n", i, *(ptr + i)); // Dereference the pointer    }    return 0;}Null pointers example: #include <stdio.h>int main() {    int *ptr = NULL; // Initialize pointer to NULL    if (ptr == NULL) {        printf("Pointer is null, safe to initialize.\n");        int var = 25;        ptr = &var; // Assign the address of var to ptr        printf("Value pointed by ptr: %d\n", *ptr); // Dereference ptr    }    return 0;}Function pointers: Example of function pointer:#include <stdio.h>// Define a functionvoid displayMessage() {    printf("Hello, World!\n");}int main() {    // Declare a function pointer    void (*funcPtr)() = displayMessage;    // Call the function using the pointer    funcPtr();    return 0;}Declaration of pointers: Pointers are declared by using the * symbol.int *ptr;  // Pointer to an integerExample of pointers: #include <stdio.h>int main() {    int num = 10;    int *ptr;  // Declare a pointer to an integer    ptr = &num;  // Assign the address of num to the pointer    printf("Value of num: %d\n", num);    printf("Address of num: %p\n", &num);    printf("Pointer ptr holds the address: %p\n", ptr);    printf("Value at the address stored in ptr: %d\n", *ptr);    return 0;}Concepts of pointers:Null pointer: int *ptr = NULL;  // Null pointerPointer arithmetic: ptr++;  // Move to the next memory location (depending on data type size)Arrays in C:int arr[5];  // Declares an array of 5 integersAccessing array elements: Array elements are accessed using indices:arr[0] = 10;  // Assigns value 10 to the first element of the arrayprintf("%d", arr[0]);  // Prints the first element of the arrayExample of arrays:#include <stdio.h>int main() {    int arr[5] = {1, 2, 3, 4, 5};  // Declares and initializes an array of 5 integers    // Accessing array elements    for (int i = 0; i < 5; i++) {        printf("Element at index %d: %d\n", i, arr[i]);    }    return 0;}Pointer and array equivalence: The array name itself is a pointer to the first element of the array:Hence, arr is equivalent to &arr[0].int *ptr = arr;  // Points to the first element of the arrayPointer arithmetic in arrays: You can increment the pointer to move from one array element to the next.printf("%d", *(ptr + 1));  // Access the second element of the array using pointer arithmeticExample of pointer and array equivalence:#include <stdio.h>int main() {    int arr[5] = {10, 20, 30, 40, 50};    int *ptr = arr;  // Pointer to the first element of the array    // Accessing array elements using pointer    for (int i = 0; i < 5; i++) {        printf("Value at arr[%d]: %d\n", i, *(ptr + i));    }    return 0;}Declaration of 2D Arrays:int matrix[3][3];  // Declares a 2D array (3 rows, 3 columns)Accessing 2D array elements using pointers: A 2D array can be accessed using pointers by understanding that it's essentially an array of arrays.Example of pointer to 2D arrays:#include <stdio.h>int main() {    int matrix[2][3] = { {1, 2, 3}, {4, 5, 6} };    int (*ptr)[3] = matrix;  // Pointer to a 2D array    // Accessing elements using pointer    for (int i = 0; i < 2; i++) {        for (int j = 0; j < 3; j++) {            printf("%d ", *(*(ptr + i) + j));  // Using pointer to access 2D array elements        }        printf("\n");    }    return 0;}Example of array of pointers:#include <stdio.h>int main() {    const char *arr[3] = {"Apple", "Banana", "Cherry"};  // Array of pointers to strings    // Accessing elements of array of pointers    for (int i = 0; i < 3; i++) {        printf("%s\n", arr[i]);    }    return 0;}Syntax:void* malloc(size_t size);size_t size: The number of bytes to be allocated.void*: Returns a pointer to the allocated memory. It needs to be typecast to the desired data type.Example of malloc():#include <stdio.h>#include <stdlib.h>int main() {    int *ptr;    int n = 5;    // Allocate memory for 5 integers    ptr = (int*) malloc(n * sizeof(int));    if (ptr == NULL) {        printf("Memory allocation failed\n");        return 1;    }    // Assign values and print them    for (int i = 0; i < n; i++) {        ptr[i] = i + 1;        printf("%d ", ptr[i]);    }    // Free the allocated memory    free(ptr);    return 0;}calloc() (contiguous allocation): Syntax:void* calloc(size_t num, size_t size);num: The number of elements.size: The size of each element in bytes.Example of calloc():#include <stdio.h>#include <stdlib.h>int main() {    int *ptr;    int n = 5;    // Allocate memory for 5 integers and initialize to zero    ptr = (int*) calloc(n, sizeof(int));    if (ptr == NULL) {        printf("Memory allocation failed\n");        return 1;    }    // Print the allocated memory values (all zero-initialized)    for (int i = 0; i < n; i++) {        printf("%d ", ptr[i]);  // Output will be 0 0 0 0 0    }    // Free the allocated memory    free(ptr);    return 0;}realloc() (reallocation): o Syntax:void* realloc(void* ptr, size_t new_size);ptr: A pointer to the previously allocated memory.new_size: The new size of the memory block in bytes.Example of realloc():#include <stdio.h>#include <stdlib.h>int main() {    int *ptr;    int n = 5;    // Allocate memory for 5 integers    ptr = (int*) malloc(n * sizeof(int));    if (ptr == NULL) {        printf("Memory allocation failed\n");        return 1;    }    // Assign values to the allocated memory    for (int i = 0; i < n; i++) {        ptr[i] = i + 1;    }    // Resize the memory block to hold 10 integers    n = 10;    ptr = (int*) realloc(ptr, n * sizeof(int));    if (ptr == NULL) {        printf("Memory reallocation failed\n");        return 1;    }    // Assign new values and print them    for (int i = 0; i < n; i++) {        printf("%d ", ptr[i]);    }    // Free the allocated memory    free(ptr);    return 0;}free() (memory deallocation): Syntax:void free(void* ptr);o ptr: A pointer to the memory block to be freed.o Example of free():#include <stdio.h>#include <stdlib.h>int main() {    // Dynamically allocate memory for an integer array of size 5    int *arr = (int *)malloc(5 * sizeof(int));        if (arr == NULL) {        printf("Memory allocation failed!\n");        return 1; // Exit the program if memory allocation fails    }    // Assign values to the array    for (int i = 0; i < 5; i++) {        arr[i] = i + 1;    }    // Print the array values    printf("Array elements: ");    for (int i = 0; i < 5; i++) {        printf("%d ", arr[i]);    }    printf("\n");    // Deallocate the allocated memory    free(arr);    // Optional: Assign NULL to the pointer after deallocation    arr = NULL;    printf("Memory deallocated successfully.\n");    return 0;}For example, passing an integer to a function by pointer:#include <stdio.h>void increment(int *num) {    *num = *num + 1;  // Dereferencing the pointer to change the value}int main() {    int x = 5;    increment(&x);  // Passing the address of x    printf("Value of x after increment: %d\n", x);  // Output: 6    return 0;}Example of returning a pointer from a function:#include <stdio.h>#include <stdlib.h>int* createArray(int size) {    int *arr = (int*) malloc(size * sizeof(int));  // Dynamically allocate memory    if (arr == NULL) {        printf("Memory allocation failed!\n");        return NULL;    }    for (int i = 0; i < size; i++) {        arr[i] = i + 1;  // Initialize array    }    return arr;  // Return pointer to the array}int main() {    int *myArray;    int size = 5;    myArray = createArray(size);  // Get the array pointer from the function    for (int i = 0; i < size; i++) {        printf("%d ", myArray[i]);  // Output: 1 2 3 4 5    }    free(myArray);  // Free the dynamically allocated memory    return 0;}Pointer to function: Declaration:return_type (*pointer_name)(parameter_list);o Example of function pointers:#include <stdio.h>void greet() {    printf("Hello, World!\n");}int main() {    void (*funcPtr)();  // Declare a pointer to a function that takes no arguments    funcPtr = &greet;   // Assign the address of the function    funcPtr();          // Call the function using the pointer (Output: Hello, World!)    return 0;}Pointers and arrays with functions: Example of passing an array (which acts as a pointer) to a function:#include <stdio.h>void modifyArray(int arr[], int size) {    for (int i = 0; i < size; i++) {        arr[i] *= 2;  // Modify array elements    }}int main() {    int arr[5] = {1, 2, 3, 4, 5};    modifyArray(arr, 5);  // Pass the array to the function    for (int i = 0; i < 5; i++) {        printf("%d ", arr[i]);  // Output: 2 4 6 8 10    }    return 0;}String as a pointer to a character array:Example:#include <stdio.h>int main() {    char str[] = "Hello, World!";  // String as a character array    char *ptr = str;  // Pointer to the first character of the string        // Accessing the string using the pointer    printf("%s\n", ptr);  // Output: Hello, World!        // Accessing individual characters using pointer arithmetic    printf("%c\n", *(ptr + 1));  // Output: e (second character in the string)        return 0;}Passing strings to functions using pointers: Strings are commonly passed to functions Example of passing a string to a function:#include <stdio.h>// Function to print a stringvoid printString(char *str) {    printf("String: %s\n", str);}int main() {    char myStr[] = "Pointers in C";        // Pass string to function    printString(myStr);  // Output: Pointers in C        return 0;}Pointer arithmetic with strings: Example of traversing a string using a pointer:#include <stdio.h>int main() {    char str[] = "Pointer Example";    char *ptr = str;        // Traverse the string and print each character    while (*ptr != '\0') {        printf("%c ", *ptr);  // Print each character        ptr++;  // Move the pointer to the next character    }    // Output: P o i n t e r  E x a m p l e        return 0;}Dynamic string allocation with pointers: Example of dynamic string allocation:#include <stdio.h>#include <stdlib.h>#include <string.h>int main() {    char *str;        // Dynamically allocate memory for 20 characters    str = (char *)malloc(20 * sizeof(char));        if (str == NULL) {        printf("Memory allocation failed!\n");        return 1;    }        // Copy a string into the allocated memory    strcpy(str, "Dynamic String");    printf("%s\n", str);  // Output: Dynamic String        // Free the allocated memory    free(str);        return 0;}Pointer to a string constant: Example of a pointer to a string constant:#include <stdio.h>int main() {    const char *str = "Hello, C!";    printf("%s\n", str);  // Output: Hello, C!        // Uncommenting the following line will cause an error (modifying string literal)    // str[0] = 'h';  // Error: Attempt to modify a read-only string        return 0;}Working with text files: Example of writing to and reading from a text file:#include <stdio.h>int main() {    FILE *filePtr;    // Writing to a file    filePtr = fopen("example.txt", "w");  // Open file in write mode    if (filePtr == NULL) {        printf("Error opening file!\n");        return 1;    }    fprintf(filePtr, "Hello, File Handling in C!\n");  // Write text to file    fclose(filePtr);  // Close the file    // Reading from a file    filePtr = fopen("example.txt", "r");  // Open file in read mode    if (filePtr == NULL) {        printf("Error opening file!\n");        return 1;    }    char buffer[50];    fgets(buffer, 50, filePtr);  // Read a line from the file    printf("File content: %s", buffer);  // Output: Hello, File Handling in C!    fclose(filePtr);  // Close the file    return 0;}Working with binary files: Example of working with a binary file:#include <stdio.h>#include <stdlib.h>struct Employee {    int id;    char name[30];    float salary;};int main() {    FILE *filePtr;    struct Employee emp = {1001, "John Doe", 75000.00};    // Writing to a binary file    filePtr = fopen("employee.dat", "wb");  // Open in binary write mode    if (filePtr == NULL) {        printf("Error opening file!\n");        return 1;    }    fwrite(&emp, sizeof(struct Employee), 1, filePtr);  // Write struct to file    fclose(filePtr);    // Reading from a binary file    filePtr = fopen("employee.dat", "rb");  // Open in binary read mode    if (filePtr == NULL) {        printf("Error opening file!\n");        return 1;    }    fread(&emp, sizeof(struct Employee), 1, filePtr);  // Read struct from file    printf("Employee ID: %d, Name: %s, Salary: %.2f\n", emp.id, emp.name, emp.salary);    fclose(filePtr);    return 0;}o In this example:* fwrite() writes the binary representation of a structure to the file.* fread() reads the structure back from the file.Example of opening a file:#include <stdio.h>int main() {    FILE *filePtr;    // Open the file for writing    filePtr = fopen("data.txt", "w");    if (filePtr == NULL) {        printf("Error opening file!\n");        return 1;  // Return if the file can't be opened    }    fprintf(filePtr, "Hello, File Handling in C!");  // Write to the file    fclose(filePtr);  // Close the file    return 0;}Closing a file: Example of closing a file:#include <stdio.h>int main() {    FILE *filePtr;    // Open the file for reading    filePtr = fopen("data.txt", "r");    if (filePtr == NULL) {        printf("Error opening file!\n");        return 1;    }    // File operations go here (e.g., reading data from the file)    fclose(filePtr);  // Close the file after use    return 0;}Reading from a file: char ch;FILE *filePtr = fopen("data.txt", "r");ch = fgetc(filePtr);  // Reads one characterprintf("Character: %c\n", ch);fclose(filePtr);Writing to a file: FILE *filePtr = fopen("output.txt", "w");fputc('A', filePtr);  // Writes the character 'A' to the filefclose(filePtr);Closing a file: FILE *filePtr = fopen("output.txt", "w");// File operations go herefclose(filePtr);  // Close the file